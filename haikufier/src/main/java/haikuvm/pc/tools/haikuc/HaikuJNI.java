package haikuvm.pc.tools.haikuc;

import haikuvm.pc.tools.Haikufy;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.HashSet;
import java.util.Set;

import org.apache.bcel.classfile.Attribute;
import org.apache.bcel.classfile.ConstantUtf8;
import org.apache.bcel.classfile.JavaClass;
import org.apache.bcel.classfile.Method;
import org.apache.bcel.classfile.Unknown;
import org.apache.bcel.generic.Type;

public class HaikuJNI {

	private static class JniAnnotation {
		static boolean isAnnotation(Attribute attribute) {
			return attribute.toString().contains(" RuntimeVisibleAnnotations:");
		}

		private String signature;
		private String impl;

		JniAnnotation(Attribute annotation) {
			byte[] annotationData = ((Unknown) annotation).getBytes();
			int signatureIndex = ((annotationData[2] & 0xff) << 8) + (annotationData[3] & 0xff);
			signature = annotation.getConstantPool().getConstant(signatureIndex).toString();
			try {
				if (annotationData.length == 11) {
					impl = ((ConstantUtf8) annotation.getConstantPool().getConstant(annotationData[10]&0xff))
							.getBytes();
				}
			} catch (Exception e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}

		boolean isNativeCFunction() {
			return signature.contains("NativeCFunction");
		}

		boolean isNativeCppFunction() {
			return signature.contains("NativeCppFunction") || signature.contains("NativeProcessingFunction");
		}

		boolean isNativeCppMethod() {
			return signature.contains("NativeCppMethod");
		}

		boolean isNativeCHeader() {
			return signature.contains("NativeCBody") || signature.contains("NativeCHeader");
		}

		boolean hasImpl() {
			return impl != null;
		}

		String getImpl() {
			return impl;
		}
	}

	private Set<String> processedHeader = new HashSet<String>();

    private PrintOnChange jni;

    private PrintOnChange nativeCF;

    private String cType;

    private Type[] at;

    private String jniName;

    private String objType;

    private boolean Cpp;

    public HaikuJNI(String dir) throws FileNotFoundException {
    	File parentDir = HaikuJava2File.getGenTargetDir();

        jni=new PrintOnChange(new File(parentDir+"/haikuJNI.c"));
        jni.println("#if justAsCutAndPastSource__CanBeDonePerClassAlsoWith__javah");
        jni.println();
        jni.println("/* DO NOT EDIT THIS FILE it is machine generated */");
        jni.println("#include <jni.h>");
        jni.println("/* Header for all classes */");
        jni.println("#ifndef _Included_allClasses");
        jni.println("#define _Included_allClasses");
        jni.println("#ifdef __cplusplus");
        jni.println("extern \"C\" {");
        jni.println("#endif");
        jni.printf("\n");
        jni.printf("/////////////////////////////////////////////////\n");
        jni.printf("\n");
        jni.printf("\n");

//        natives=new PrintStream(new File(dir+"/"+Haikufy.choice("haikuC")+"/haikuNatives.c"));
//        natives.println("/* DO NOT EDIT THIS FILE – it is machine generated */");
//        natives.println("#include <jni.h>");
//        natives.println("#ifdef __cplusplus");
//        natives.println("extern \"C\" {");
//        natives.println("#endif");
//        natives.printf("\n");
//        natives.printf("/////////////////////////////////////////////////\n");
//        natives.printf("\n");

        nativeCF=new PrintOnChange(new File(parentDir+"/nativeCFunctions.cpp"));
        nativeCF.println("#include <stdlib.h>");
        nativeCF.println("#include <math.h>");
        nativeCF.println("#include <string.h>");
        nativeCF.println("#include \"jni.h\"");
        nativeCF.println("#include \"haikuByteCodeTypes.h\"");
        nativeCF.println("#include \"haikuConfig.h\"");
        nativeCF.printf("\n");
        nativeCF.printf("/////////////////////////////////////////////////\n");
        nativeCF.printf("\n");
        nativeCF.printf("\n");
  }

    public void close() throws IOException {
		jni.println("#ifdef __cplusplus");
        jni.println("}");
        jni.println("#endif");
        jni.println("#endif");
        jni.println();
        jni.println("#endif");
        jni.close();
        nativeCF.close();

//        natives.println("#ifdef __cplusplus");
//        natives.println("}");
//        natives.println("#endif");
//        natives.close();
    }

    private String stackType(Type type) {
        if (type==Type.DOUBLE)  return "d";
        if (type==Type.LONG)    return "j";
        if (type==Type.INT)     return "i";
        if (type==Type.SHORT)   return "i";
        if (type==Type.BYTE)    return "i";
        if (type==Type.BOOLEAN) return "i";
        if (type==Type.CHAR)    return "i";
        if (type==Type.FLOAT)   return "f";
        return "a";
    }

	private void classHeader(JavaClass javaClass, String className) {
		if (processedHeader.contains(className)) {
			return;
		}

		JniAnnotation annotation = getNativeCAnnotations(javaClass.getAttributes());
		if (annotation!=null && annotation.hasImpl()) {
	        nativeCF.printf(  "//////////////////Start of user code given per Java class by cImpl\n");
			nativeCF.print(annotation.getImpl());
	        nativeCF.printf("\n//////////////////End   of user code given per Java class by cImpl\n");
			processedHeader.add(className);
		}
	}

	public void nativeInfo(JavaClass javaClass, String className, Method method, String cMethodName) throws IOException {
		classHeader(javaClass, className);
		nativeInfo0(className, method, cMethodName);
		defaultCFunction(className, method, cMethodName);
	}

	private JniAnnotation getNativeCAnnotations(Attribute[] attributes) {
		for (Attribute attribute : attributes) {
			if (JniAnnotation.isAnnotation(attribute)) {
				JniAnnotation annotation = new JniAnnotation(attribute);
				if (annotation.isNativeCHeader() || annotation.isNativeCFunction() || annotation.isNativeCppFunction() || annotation.isNativeCppMethod()) {
					return annotation;
				}
			}
		}
		return null;
	}

    /**
     * support for annotation NativeCFunction
     */
    private void defaultCFunction(String classname, Method method, String cMethodName) throws IOException {
        JniAnnotation annotation=getNativeCAnnotations(method.getAttributes());
    	if (annotation==null) {
    		return;
    	}

		if (!processedHeader.contains(classname) && !annotation.hasImpl()) {
	        // extern ["C" ]
	        if (annotation.isNativeCFunction()) {
	            Cpp=false;
	            nativeCF.printf("#ifndef "+method.getName()+"\n");
	            nativeCF.printf("extern \"C\" ");
	        } else if (annotation.isNativeCppFunction()||annotation.isNativeCppMethod()) {
	            Cpp=true;
	            nativeCF.printf("#ifndef "+method.getName()+"\n");
	            nativeCF.printf("extern ");
	        } else {
	            return;
	        }
	        // extern ["C" ] int
	        classname=classname.replace('/', '.').replace('\\', '.');
	        if (method.getReturnType()!=Type.VOID) {
	            nativeCF.printf(basicCtype(cType)+" ");
	        } else {
	            nativeCF.printf("void ");
	        }

	        // extern ["C" ] int putchar(
	        nativeCF.printf(method.getName()+"(");
	        // extern ["C" ] int putchar(int
	        for (int i = 0; i<at.length; i++) {
	            if (i>0) nativeCF.printf(", ");
	            nativeCF.printf(basicCtype(at[i].toString()));
	        }
	        // extern ["C" ] int putchar(int);
	        nativeCF.printf(");\n");
	        nativeCF.printf("#endif\n");
		}

        nativeCF.printf("\n");
        nativeCF.printf("/*\n");
        nativeCF.printf(" * Class:     %s\n", classname);
        nativeCF.printf(" * Method:    %s\n", method.getName());
        nativeCF.printf(" * Signature: %s\n", method.getSignature());
        nativeCF.printf(" */\n");
        nativeCF.printf("JNIEXPORT %s %s\n  (JNIEnv *env, %s obj", cType, jniName, objType);
        for (int i = 0; i<at.length; i++) {
            String paramType = Haikufy.signature2JNI(at[i].toString());
            if (stackType(at[i]).equals("a")) {
                paramType = "jobject";
            }
            nativeCF.printf(", %s arg%d", paramType, i+1);
        }
        nativeCF.printf(")\n{\n");

		if (annotation!=null && annotation.hasImpl()) {
	        nativeCF.printf(  "//////////////////Start of user code given by cImpl\n");
	        nativeCF.print(annotation.getImpl());
	        nativeCF.printf("\n//////////////////End   of user code given by cImpl\n");
		} else {
	        nativeCF.print(getDefaultCImpl(annotation, classname, method));
		}
        nativeCF.printf("}\n");
        nativeCF.printf("\n");

        proprietaryAdapter(nativeCF, classname, method, cMethodName);
    }

    /**
     * One liner e.g. like this:
     *   return DOUBLE2TD(sin(TD2DOUBLE(arg1)));
     * or this:
     *   return DOUBLE2TD(result);
     *
     * @param method
     * @return
     */
	private String getDefaultCImpl(JniAnnotation annotation, String classname, Method method) {
		StringBuilder buffer = new StringBuilder();

		if (method.getReturnType() != Type.VOID) {
			buffer.append("    return ");
		} else {
			buffer.append("    ");
		}
		if (cType.equals("jdouble")) {
			buffer.append("DOUBLE2TD(");
		}
		if (cType.equals("jfloat")) {
			buffer.append("FLOAT2TF(");
		}
		if (annotation.isNativeCppMethod()) {
			if (method.isStatic()) {
				if ( (method.getName().equals(getCppClassName(classname)) || method.getName().equals("cppConstructor")) && method.getReturnType() != Type.VOID) {
					buffer.append("(jobject) new ");
				} else {
					buffer.append(getCppClassName(classname) + "::");
				}
			} else {
				buffer.append("(*("+getCppClassName(classname)+"**) obj)->");
			}
		}
		Type[] at = method.getArgumentTypes();
		buffer.append(method.getName() + "(");
		for (int i = 0; i < at.length; i++) {
			if (i > 0)
				buffer.append(", ");
			String paramType = Haikufy.signature2JNI(at[i].toString());
			if (paramType.equals("jdouble")) {
				buffer.append("TD2DOUBLE(");
			}
			if (paramType.equals("jfloat")) {
				buffer.append("TF2FLOAT(");
			}
			buffer.append("arg" + (i + 1));
			if (paramType.equals("jdouble") || paramType.equals("jfloat")) {
				buffer.append(")");
			}
		}

		if (cType.equals("jdouble") || cType.equals("jfloat")) {
			buffer.append(")");
		}
		buffer.append(");\n");

		return buffer.toString();
	}

    private String getCppClassName(String jclassname) {
		String ccname=jclassname.replaceFirst(".*/", "");
		if (ccname.length()==0) return jclassname;
		return ccname;
	}

	private String basicCtype(String javaType) {
        String paramType = Haikufy.signature2JNI(javaType);
        paramType=paramType.replace("jobject", "void *");
        paramType=paramType.replace("jbyte", "jchar"); // just to replace it by "unsigned char" or "char"
        paramType=paramType.replace("jdouble", "double");
        paramType=paramType.replace("jfloat", "float");
        if (Cpp) {
            paramType=paramType.replaceFirst("j", "unsigned ");
        } else {
            paramType=paramType.replaceFirst("j", "");
        }
        return paramType;
    }

    /**
     * Produces haikuJNI.c to stay near with standard JNI and javah.
     * Just as cut&past source. Can be done per class when using standard javah.
     * #if justAsCutAndPastSource__CanBeDonePerClassAlsoWith__javah
     *
     * @param classname
     * @param method
     * @param cMethodName
     * @throws IOException
     */
    private void nativeInfo0(String classname, Method method, String cMethodName) throws IOException {
        classname=classname.replace('/', '.').replace('\\', '.');
        String name = method.getName();
        int pos=cMethodName.lastIndexOf("_"+name+"_");
        jniName = "Java_"+cMethodName.substring(0, pos+name.length()+1);
        objType="jobject";
        if (method.isStatic()) {
            objType="jclass";
        }
        if (method.getReturnType()==Type.VOID) {
            cType = "void";
        } else {
            cType = Haikufy.signature2JNI(method.getReturnType().toString());
            if (stackType(method.getReturnType()).equals("a")) {
                cType = "jobject";
            }
        }
        at = method.getArgumentTypes();


        jni.printf("/*\n");
        jni.printf(" * Class:     %s\n", classname);
        jni.printf(" * Method:    %s\n", method.getName());
        jni.printf(" * Signature: %s\n", method.getSignature());
        jni.printf(" */\n");
        jni.printf("JNIEXPORT %s %s\n  (JNIEnv *, %s", cType, jniName, objType);
        for (int i = 0; i<at.length; i++) {
            String paramType = Haikufy.signature2JNI(at[i].toString());
            if (stackType(at[i]).equals("a")) {
                paramType = "jobject";
            }
            jni.printf(", %s", paramType);
        }
        jni.printf(");\n");
        jni.printf("\n");


        jni.printf("JNIEXPORT %s %s JNICALL\n  (JNIEnv *env, %s obj", cType, jniName, objType);
        for (int i = 0; i<at.length; i++) {
            String paramType = Haikufy.signature2JNI(at[i].toString());
            if (stackType(at[i]).equals("a")) {
                paramType = "jobject";
            }
            jni.printf(", %s arg%d", paramType, i+1);
        }
        jni.printf(")\n{\n");
        jni.printf("    // TODO: insert your code here\n");
        if (method.getReturnType()!=Type.VOID) {
            if (cType.equals("jobject")) {
                jni.printf("    return NULL;\n");
            } else {
                jni.printf("    return 0;\n");
            }
        }
        jni.printf("}\n");
        jni.printf("\n");

        proprietaryAdapter(jni, classname, method, cMethodName);
    }

    private void proprietaryAdapter(PrintOnChange out, String classname, Method method, String cMethodName) {
        out.printf("/*\n");
        out.printf(" * Proprietary HaikuVM stack to JNI Adapter function.\n");
        out.printf(" * DO NOT EDIT THIS FUNCTION - it is machine generated.\n");
        out.printf(" * \n");
        out.printf(" * Class:     %s\n", classname);
        out.printf(" * Method:    %s\n", method.getName());
        out.printf(" * Signature: %s\n", method.getSignature());
        out.printf(" */\n");
        out.printf("JNIEXPORT void native_%s(void) {\n", cMethodName);
        out.printf("    pushTop();    // Save variable top onto stack.\n");
        out.printf("    {\n");

        for (int i = at.length-1; i>=0; i--) {
            String paramType = Haikufy.signature2JNI(at[i].toString());
            if (stackType(at[i]).equals("a")) {
                paramType = "jobject";
            }
            String sType = stackType(at[i]);
            if (at[i]==Type.DOUBLE || at[i]==Type.LONG) {
                out.printf("        %s    arg%d = popp2()->%s;\n", paramType, i+1, sType);
            } else {
                out.printf("        %s    arg%d = (%s)pop()->%s;\n", paramType, i+1, paramType, sType);
            }
        }
        String args = "";
        for (int i = 0; i<at.length; i++) {
            args+=", arg"+(i+1);
        }

        if (method.isStatic()) {
            out.printf("        jclass     obj = NULL;\n");
        } else {
            out.printf("        jobject    obj = pop()->a;\n");
        }
        out.printf("        JNIEnv     *env = (JNIEnv*)&top;\n");


        if (method.getReturnType()==Type.VOID) {
            out.printf("        %s((JNIEnv*)&env, obj%s);\n", jniName, args);
            out.printf("    }\n");
            out.printf("    popTop();\n");
        } else {
            String sType = stackType(method.getReturnType());
            if (sType.equals("j") || sType.equals("d")) {
                out.printf("        top.%s = %s((JNIEnv*)&env, obj%s);\n", sType, jniName, args);
                out.printf("    }\n");
                out.printf("    // Variable top holds the return value. But we have to push the lower half.\n");
                out.printf("    pushTop0();\n");
            } else {
                out.printf("        top.%s = %s((JNIEnv*)&env, obj%s);\n", "s1."+sType, jniName, args);
                out.printf("    }\n");
                out.printf("    // Variable top holds the return value.\n");
            }
        }
        out.printf("}\n");
        out.printf("\n");
        out.printf("/////////////////////////////////////////////////\n");
        out.printf("\n");
        out.printf("\n");
   }

}
